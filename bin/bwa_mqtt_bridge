#!/usr/bin/env ruby

require 'mqtt'
require 'sd_notify'
require 'set'
require 'json'

require 'bwa/client'
require 'bwa/discovery'

class MQTTBridge
  def initialize(mqtt_uri, bwa, device_id: "bwa", base_topic: "homie")
    @base_topic = "#{base_topic}/#{device_id}"
    @mqtt = MQTT::Client.new(mqtt_uri)
    @mqtt.set_will("#{@base_topic}/$state", "lost", true)
    @mqtt.connect
    @bwa = bwa
    @attributes = {}
    @things = Set.new
    if ENV["HASS_ENABLED"] == "true"
      @hass_enabled = true
    end


    hass_discovery_topic = "homeassistant/"
    @ha_binary_path = hass_discovery_topic + "binary_sensor/"
    @ha_sensor_path = hass_discovery_topic + "sensor/"
    @ha_switch_path = hass_discovery_topic + "switch/"
    @ha_selects_path = hass_discovery_topic + "select/"
    @ha_number_path = hass_discovery_topic + "number/"

    @hass_device = {
      "device" => {
        "identifiers" => ["spa_CL501X1"],
        "sw_version" => "2021.11",
        "name" => "BWA Link"
      }
    }

    # bwa availability topics (works for all devices)
    @hass_availability = {
      "availability_topic" => "homie/bwa/$state",
      "payload_available" => "ready",
      "payload_not_available" => "lost"
    }

    publish_basic_attributes

    # Home Assistant MQTT Discovery Section
    publish_hass_discovery if @hass_enabled

    # Tell systemd we've started up OK. Ignored if systemd not in use.
    SdNotify.ready

    bwa_thread = Thread.new do
      loop do
        begin
          message = @bwa.poll
          next if message.is_a?(BWA::Messages::Ready)

          puts message.inspect unless message.is_a?(BWA::Messages::Status)
          case message
          when BWA::Messages::ControlConfiguration
            publish("spa/$type", message.model)
          when BWA::Messages::ControlConfiguration2
            message.pumps.each_with_index do |speed, i|
              publish_pump(i + 1, speed) if speed != 0
            end
            message.lights.each_with_index do |exists, i|
              publish_thing("light", i + 1) if exists
            end
            message.aux.each_with_index do |exists, i|
              publish_thing("aux", i + 1) if exists
            end
            publish_mister if message.mister
            publish_blower(message.blower) if message.blower != 0
            publish_circpump if message.circ_pump
            publish("$state", "ready")
          when BWA::Messages::Status
            @bwa.request_control_info unless @bwa.last_control_configuration
            @bwa.request_control_info2 unless @bwa.last_control_configuration2

            # make sure time is in sync
            now = Time.now
            now_minutes = now.hour * 60 + now.min
            spa_minutes = message.hour * 60 + message.minute
            # check the difference in both directions
            diff = [(spa_minutes - now_minutes) % 1440, 1440 - (spa_minutes - now_minutes) % 1440].min

            # allow a skew of 1 minute, since the seconds will always be off
            if diff > 1
              @bwa.set_time(now.hour, now.min, message.twenty_four_hour_time)
            end
            publish_attribute("spa/priming", message.priming)
            publish_attribute("spa/heatingmode", message.heating_mode)
            publish_attribute("spa/temperaturescale", message.temperature_scale)
            publish_attribute("spa/24htime", message.twenty_four_hour_time)
            publish_attribute("spa/heating", message.heating)
            publish_attribute("spa/temperaturerange", message.temperature_range)
            publish_attribute("spa/currenttemperature", message.current_temperature)
            publish_attribute("spa/currenttemperature/$unit", "º#{message.temperature_scale.to_s[0].upcase}")
            publish_attribute("spa/settemperature", message.set_temperature)
            publish_attribute("spa/settemperature/$unit", "º#{message.temperature_scale.to_s[0].upcase}")
            if message.temperature_scale == :celsius
              publish_attribute("spa/currenttemperature/$format", message.temperature_range == :high ? "26:40" : "10:26")
              publish_attribute("spa/settemperature/$format", message.temperature_range == :high ? "26:40" : "10:26")
              publish_hass_discovery_settemp(:celsius) if @hass_enabled
            else
              publish_attribute("spa/currenttemperature/$format", message.temperature_range == :high ? "80:104" : "50:99")
              publish_attribute("spa/settemperature/$format", message.temperature_range == :high ? "80:104" : "50:99")
              publish_hass_discovery_settemp(:fahrenheit) if @hass_enabled
            end
            publish_attribute("spa/filter1", message.filter[0])
            publish_attribute("spa/filter2", message.filter[1])

            publish_attribute("spa/circpump", message.circ_pump) if @bwa.last_control_configuration2&.circ_pump
            publish_attribute("spa/blower", message.blower) if @bwa.last_control_configuration2&.blower.to_i != 0
            publish_attribute("spa/mister", message.mister) if @bwa.last_control_configuration2&.mister
            (0..5).each do |i|
              publish_attribute("spa/pump#{i + 1}", message.pumps[i]) if @bwa.last_control_configuration2&.pumps&.[](i).to_i != 0
            end
            (0..1).each do |i|
              publish_attribute("spa/light#{i + 1}", message.lights[i]) if @bwa.last_control_configuration2&.lights&.[](i)
            end
            (0..1).each do |i|
              publish_attribute("spa/aux#{i + 1}", message.lights[i]) if @bwa.last_control_configuration2&.aux&.[](i)
            end

            # Tell systemd we are still alive and kicking. Ignored if systemd not in use.
            SdNotify.watchdog
          end
        end
      end
    end

    @mqtt.get do |topic, value|
      puts "got #{value.inspect} at #{topic}"
      case topic[@base_topic.length + 1..-1]
      when "spa/heatingmode/set"
        next @bwa.toggle_heating_mode if value == 'toggle'
        next unless %w{ready rest}.include?(value)
        @bwa.set_heating_mode(value.to_sym)
      when "spa/temperaturescale/set"
        next unless %w{fahrenheit celsius}.include?(value)
        @bwa.set_temperature_scale(value.to_sym)
      when "spa/24htime/set"
        next unless %w{true false}.include?(value)
        now = Time.now
        @bwa.set_time(now.hour, now.min, value == 'true')
      when "spa/temperaturerange/set"
        next @bwa.toggle_temperature_range if value == 'toggle'
        next unless %w{low high}.include?(value)
        @bwa.set_temperature_range(value.to_sym)
      when %r{^spa/pump([1-6])/set$}
        next @bwa.toggle_pump($1.to_i) if value == 'toggle'
        @bwa.set_pump($1.to_i, value.to_i)
      when %r{^spa/(light|aux)([12])/set$}
        next @bwa.send(:"toggle_#{$1}", $2.to_i) if value == 'toggle'
        next unless %w{true false}.include?(value)
        @bwa.send(:"set_#{$1}", $2.to_i, value == 'true')
      when "spa/mister/set"
        next @bwa.toggle_mister if value == 'toggle'
        next unless %w{true false}.include?(value)
        @bwa.set_mister(value == 'true')
      when "spa/blower/set"
        next @bwa.toggle_blower if value == 'toggle'
        @bwa.set_blower(value.to_i)
      when "spa/settemperature/set"
        @bwa.set_temperature(value.to_f)
      end
    end
  end

  def publish(topic, value)
    @mqtt.publish("#{@base_topic}/#{topic}", value, true)
  end

  def publish_attribute(attr, value)
    if !@attributes.key?(attr) || @attributes[attr] != value
      publish(attr, value.to_s)
      @attributes[attr] = value
    end
  end

  def subscribe(topic)
    @mqtt.subscribe("#{@base_topic}/#{topic}")
  end

  def publish_hass_discovery()
    #Priming
    priming_config = {
      "name" => "Hot Tub Priming",
      "state_topic" => "homie/bwa/spa/priming",
      "device_class" => "running",
      "unique_id" => "spa_priming",
      "icon" => "mdi:fast-forward"
    }
    @mqtt.publish(@ha_binary_path + "priming/config", priming_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    #Circulation Pump
    circ_config = {
      "name" => "Hot Tub Circulation Pump",
      "state_topic" => "homie/bwa/spa/circpump",
      "device_class" => "running",
      "unique_id" => "spa_circpump",
      "icon" => "mdi:sync"
    }
    @mqtt.publish(@ha_binary_path + "circpump/config", circ_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Filter 1 Cycle Running
    filter1_config = {
      "name" => "Hot Tub Filter 1 Cycle Running",
      "state_topic" => "homie/bwa/spa/filter1",
      "device_class" => "running",
      "unique_id" => "spa_filtercycle1",
      "icon" => "mdi:air-filter"
    }
    @mqtt.publish(@ha_binary_path + "filter1/config", filter1_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Filter 2 Cycle Running
    filter2_config = {
      "name" => "Hot Tub Filter 2 Cycle Running",
      "state_topic" => "homie/bwa/spa/filter2",
      "device_class" => "running",
      "unique_id" => "spa_filtercycle2",
      "icon" => "mdi:air-filter"
    }
    @mqtt.publish(@ha_binary_path + "filter2/config", filter2_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Heater Running
    heater_config = {
      "name" => "Hot Tub Heater",
      "state_topic" => "homie/bwa/spa/heating",
      "device_class" => "running",
      "unique_id" => "spa_heating",
      "icon" => "mdi:hot-tub"
    }
    @mqtt.publish(@ha_binary_path + "heating/config", heater_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Heating Mode
    heatingmode_config = {
      "name" => "Hot Tub Heating Mode",
      "state_topic" => "homie/bwa/spa/heatingmode",
      "command_topic" => "homie/bwa/spa/heatingmode/set",
      "unique_id" => "spa_heating_mode",
      "options" => ["ready","rest","ready_in_rest"],
      "icon" => "mdi:cog-play"
    }
    @mqtt.publish(@ha_selects_path + "heatingmode/config", heatingmode_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Temperature Range
    temperaturerange_config = {
      "name" => "Hot Tub Temperature Range",
      "state_topic" => "homie/bwa/spa/temperaturerange",
      "command_topic" => "homie/bwa/spa/temperaturerange/set",
      "unique_id" => "spa_temperaturerange_range",
      "options" => ["high","low"],
      "icon" => "mdi:thermometer-lines"
    }
    @mqtt.publish(@ha_selects_path + "temperaturerange/config", temperaturerange_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Temperature Scale
    temperaturescale_config = {
      "name" => "Hot Tub Temperature Scale",
      "state_topic" => "homie/bwa/spa/temperaturescale",
      "unique_id" => "spa_temperaturescale"
    }
    @mqtt.publish(@ha_sensor_path + "temperaturescale/config", temperaturescale_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Current Temperature
    currenttemperature_config = {
      "name" => "Hot Tub Current Temperature",
      "state_topic" => "homie/bwa/spa/currenttemperature",
      "unique_id" => "spa_currenttemperature",
      "device_class" => "temperature"
    }
    @mqtt.publish(@ha_sensor_path + "currenttemperature/config", currenttemperature_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)

    # Set Temperature - Assuming fahrenheit first
    settemperature_config = {
      "name" => "Hot Tub Set Temperature",
      "unique_id" => "spa_settemperature",
      "state_topic" => "homie/bwa/spa/settemperature",
      "command_topic" => "homie/bwa/spa/settemperature/set",
      "min" => 50,
      "max" => 104,
      "unit_of_measurement" => "°F",
      "icon" => "mdi:thermometer"
    }
    @mqtt.publish(@ha_number_path + "settemperature/config", settemperature_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)
  end

  def publish_hass_discovery_settemp(scale)
    # Update temp ranges when scale changes
    settemperature_config = {
      "name" => "Hot Tub Set Temperature",
      "unique_id" => "spa_settemperature",
      "state_topic" => "homie/bwa/spa/settemperature",
      "command_topic" => "homie/bwa/spa/settemperature/set",
      "min" => 50,
      "max" => 104,
      "unit_of_measurement" => "°F",
      "icon" => "mdi:thermometer"
    }

    if scale == :celsius
      settemperature_config["min"] = 10
      settemperature_config["max"] = 40
      settemperature_config["unit_of_measurement"] = "°C"
    else
      settemperature_config["min"] = 50
      settemperature_config["max"] = 104
      settemperature_config["unit_of_measurement"] = "°F"
    end

    @mqtt.publish(@ha_number_path + "settemperature/config", settemperature_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)
  end

  def publish_hass_discovery_pumps(i, speeds)
    #Pump
    # This tries to work around the "toggle" logic
    # "options" => ("0".."#{speeds}").to_a,
    pump_config = {
      "name" => "Hot Tub Pump #{i}",
      "unique_id" => "spa_pump#{i}",
      "state_topic" => "homie/bwa/spa/pump#{i}",
      "command_topic" => "homie/bwa/spa/pump#{i}/set",
      "payload_on" => "toggle",
      "payload_off" => "toggle",
      "state_on" => "2",
      "state_off" => "0",
      "icon" => "mdi:chart-bubble"
    }
    @mqtt.publish(@ha_switch_path + "pump#{i}/config", pump_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)
  end

  def publish_hass_discovery_things(type, i)
    #Things - Lights and such
    thing_config = {
      "name" => "Hot Tub #{type} #{i}",
      "unique_id" => "spa_#{type}#{i}",
      "state_topic" => "homie/bwa/spa/#{type}#{i}",
      "command_topic" => "homie/bwa/spa/#{type}#{i}/set",
      "payload_on" => "true",
      "payload_off" => "false",
      "state_on" => "true",
      "state_off" => "false"
    }
    case type
    when "light"
      thing_config["icon"] = "mdi:car-parking-lights"
    when "mister"
      thing_config["icon"] = "mdi:sprinkler-fire"
    when "blower"
      thing_config["icon"] = "mdi:chart-bubble"
    end
    @mqtt.publish(@ha_switch_path+ "#{type}#{i}/config", thing_config
      .merge(@hass_device)
      .merge(@hass_availability)
      .to_json, true)
  end

  def publish_basic_attributes
    publish("$homie", "4.0.0")
    publish("$name", "BWA Spa")
    publish("$state", "init")
    publish("$nodes", "spa")

    publish("spa/$name", "BWA Spa")
    publish("spa/$type", "spa")
    publish_nodes

    publish("spa/priming/$name", "Is the pump priming")
    publish("spa/priming/$datatype", "boolean")

    publish("spa/heatingmode/$name", "Current heating mode")
    publish("spa/heatingmode/$datatype", "enum")
    publish("spa/heatingmode/$format", "ready,rest,ready_in_rest")
    publish("spa/heatingmode/$settable", "true")
    subscribe("spa/heatingmode/set")

    publish("spa/temperaturescale/$name", "Temperature scale")
    publish("spa/temperaturescale/$datatype", "enum")
    publish("spa/temperaturescale/$format", "fahrenheit,celsius")
    publish("spa/temperaturescale/$settable", "true")
    subscribe("spa/temperaturescale/set")

    publish("spa/24htime/$name", "Clock is 24 hour time")
    publish("spa/24htime/$datatype", "boolean")
    publish("spa/24htime/$settable", "true")
    subscribe("spa/24htime/set")

    publish("spa/heating/$name", "Heater is currently running")
    publish("spa/heating/$datatype", "boolean")

    publish("spa/temperaturerange/$name", "Current temperature range")
    publish("spa/temperaturerange/$datatype", "enum")
    publish("spa/temperaturerange/$format", "high,low")
    publish("spa/temperaturerange/$settable", "true")
    subscribe("spa/temperaturerange/set")

    publish("spa/currenttemperature/$name", "Current temperature")
    publish("spa/currenttemperature/$datatype", "float")

    publish("spa/settemperature/$name", "Set Temperature")
    publish("spa/settemperature/$datatype", "float")
    publish("spa/settemperature/$settable", "true")
    subscribe("spa/settemperature/set")

    publish("spa/filter1/$name", "Filter cycle 1 is currently running")
    publish("spa/filter1/$datatype", "boolean")

    publish("spa/filter2/$name", "Filter cycle 2 is currently running")
    publish("spa/filter2/$datatype", "boolean")
  end

  def publish_pump(i, speeds)
    publish("spa/pump#{i}/$name", "Pump #{i} speed")
    publish("spa/pump#{i}/$datatype", "integer")
    publish("spa/pump#{i}/$format", "0:#{speeds}")
    publish("spa/pump#{i}/$settable", "true")
    subscribe("spa/pump#{i}/set")

    @things << "pump#{i}"
    publish_hass_discovery_pumps(i, speeds) if @hass_enabled
    publish_nodes
  end

  def publish_thing(type, i)
    publish("spa/#{type}#{i}/$name", "#{type} #{i}")
    publish("spa/#{type}#{i}/$datatype", "boolean")
    publish("spa/#{type}#{i}/$settable", "true")
    subscribe("spa/#{type}#{i}/set")

    @things << "#{type}#{i}"
    publish_hass_discovery_things(type, i) if @hass_enabled
    publish_nodes
  end

  def publish_mister
    publish("spa/mister/$name", type)
    publish("spa/mister/$datatype", "boolean")
    publish("spa/mister/$settable", "true")
    subscribe("spa/mister/set")

    @things << "mister"
    publish_nodes
  end

  def publish_blower(speeds)
    publish("spa/blower/$name", "Blower speed")
    publish("spa/blower/$datatype", "integer")
    publish("spa/blower/$format", "0:#{speeds}")
    publish("spa/blower/$settable", "true")
    subscribe("spa/blower/set")

    @things << "blower"
    publish_nodes
  end

  def publish_circpump
    publish("spa/circpump/$name", "Circ pump is currently running")
    publish("spa/circpump/$datatype", "boolean")
    @things << "circpump"

    publish_nodes
  end

  def publish_nodes
    publish("spa/$properties", (["priming,heatingmode,temperaturescale,24htime,heating,temperaturerange,currenttemperature,settemperature,filter1,filter2"] + @things.to_a).join(','))
  end
end

mqtt_uri = ARGV.shift

if ARGV.empty?
  spas = BWA::Discovery.discover
  if spas.empty?
    $stderr.puts "Could not find spa!"
    exit 1
  end
  spa_ip = "tcp://#{spas.first.first}/"
else
  spa_ip = ARGV[0]
end

spa = BWA::Client.new(spa_ip)

spa.request_configuration

MQTTBridge.new(mqtt_uri, spa)
